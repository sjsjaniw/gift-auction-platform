# Gift Auction

Решение задачи по реализации бэкенда для аукционов цифровых подарков.
Основная цель — реализовать механику многораундовых аукционов с корректной обработкой конкурентных запросов и финансовой логики.

Live Demo - 193.124.114.141
Video - https://www.youtube.com/watch?v=obRib1Z4i60

## Как я понял задачу (Механика)

В ТЗ не было жестких требований, поэтому логика аукциона реализована следующим образом (на основе анализа реальных аукционов Telegram):

1. **Раунды и распределение**
   Весь пул подарков (например, 1000 шт) делится на 50 раундов. В каждом раунде разыгрывается по 20 подарков.
   - Первый раунд длится 1 час (для сбора участников).
   - Последующие раунды — по 5 минут.
   - Победители раунда (топ-20) получают подарок и выбывают из аукциона.
   - Проигравшие автоматически переходят в следующий раунд с сохранением своих ставок.

2. **Ценообразование**
   Изначально есть фиксированная стартовая цена.
   Как только количество участников превышает количество призов (конкуренция), включается динамическая минимальная ставка. Она рассчитывается как:
   `Цена ставки последнего победного места + 1`.
   Это заставляет участников перебивать нижнюю границу топа.

3. **Работа с деньгами**
   - При ставке средства списываются с основного баланса и переходят в "замороженный" (frozen).
   - Если пользователь побеждает: замороженные средства списываются окончательно, выдается подарок.
   - Если пользователь проигрывает (аукцион завершился, а он не выиграл ни в одном раунде): средства размораживаются и возвращаются на баланс.

4. **Anti-Sniping**
   Если ставка, меняющая состав победителей, делается в последние 30 секунд раунда, то раунд продлевается еще на 30 секунд. Это дает возможность другим участникам отреагировать.

### Стек технологий
*   **Runtime:** Node.js + TypeScript
*   **Database:** MongoDB (Replica Set) — для ACID-транзакций.
*   **Cache/Lock:** Redis — для лидербордов и распределенных блокировок.
*   **Transport:** Socket.io (Realtime updates) + Express (REST API).

### Поток обработки ставки (Bid Flow)
Чтобы избежать **Race Conditions** (когда два юзера тратят одни и те же деньги или занимают одно место), реализован строгий пайплайн:

1.  **Request:** Юзер отправляет ставку.
2.  **Redlock (Redis):** Система берет распределенную блокировку на ID аукциона/юзера. Параллельные запросы встают в очередь или отклоняются.
3.  **Transaction (MongoDB):**
    *   Проверка баланса.
    *   Атомарное обновление: `$inc: { balance: -diff, frozen: +diff }`.
    *   Создание записи `Bid`.
4.  **Rank Update:** Обновление Redis ZSET (Sorted Set) для мгновенного пересчета топа.
5.  **Broadcast:** Рассылка нового состояния всем клиентам через WebSocket.

## Запуск проекта локально

Проект упакован в Docker Compose для быстрого запуска.

1. Склонируйте репозиторий:
```bash
git clone https://github.com/sjsjaniw/gift-auction-platform app
cd app
```

2. Запустите проект:
```bash
docker-compose up -d --build
```
Эта команда поднимет API, MongoDB, Redis и веб-интерфейс.

3. Откройте в браузере:
- http://localhost:3000

## Демо-режим и Тестирование (Stress Test Suite)

Для проверки работы реализован режим симуляции. Кнопка **"Reset & Start Simulation"** запускает последовательный скрипт теста системы (Unit-тесты на живом бэкенде).

Сценарий выполняет следующие шаги (смотреть логи в терминале):

1. **Race Condition Test:**
   Два бота пытаются сделать ставку с одинаковой ценой в одну и ту же миллисекунду.

2. **Double Spend Test:**
   Бот с балансом, достаточным только для одной ставки, отправляет 5 параллельных запросов.

3. **Anti-Sniping Test:**
   Бот делает ставку за 10 секунд до конца раунда, продлевая его.

4. **Chaos Mode (Нагрузка):**
   Запускается 100 ботов, которые в течение минуты спамят случайными ставками, создавая конкуренцию и повышая цену.

5. **Financial Audit:**
   В конце симуляции скрипт подсчитывает сумму всех денег у всех пользователей и сравнивает с начальной эмиссией (с учетом потраченных на тесты средств).

**Как увидеть результаты тестов:**
Так как тесты выполняются на сервере, подробный отчет (PASS/FAIL) выводится в логи Docker-контейнера:

```bash
docker-compose logs -f app
```
